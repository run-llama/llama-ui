{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "file-uploader",
  "type": "registry:block",
  "title": "File Uploader",
  "description": "A file uploader component with drag and drop support",
  "files": [
    {
      "path": "registry/new-york/file-uploader/file-uploader.tsx",
      "content": "import * as React from \"react\";\nimport { useState } from \"react\";\nimport { Loader2, Upload, X } from \"lucide-react\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { validateFile, FileType } from \"./file-utils\";\nimport { useFileUpload, type FileUploadData } from \"./use-file-upload\";\nimport { useUploadProgress } from \"./use-upload-progress\";\nimport { UploadProgress } from \"./upload-progress\";\n\nexport interface InputField {\n  key: string;\n  label: string;\n  placeholder?: string;\n  required?: boolean;\n  validation?: (value: string) => string | null;\n}\n\nexport interface FileUploaderProps {\n  title?: string;\n  description?: string;\n  inputFields?: InputField[];\n  allowedFileTypes?: FileType[];\n  maxFileSizeBytes?: number;\n  multiple?: boolean;\n  onSuccess: (\n    data: FileUploadData[],\n    fieldValues: Record<string, string>,\n  ) => Promise<void>;\n  trigger?: React.ReactNode;\n  /** Set to true while processing the file after a callback, in order to show a spinner */\n  isProcessing?: boolean;\n}\n\nexport function FileUploader({\n  title,\n  description,\n  inputFields,\n  allowedFileTypes = [],\n  maxFileSizeBytes = 100 * 1024 * 1024, // 100MB default\n  multiple = false,\n  onSuccess,\n  trigger,\n  isProcessing = false,\n}: FileUploaderProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [fieldValues, setFieldValues] = useState<Record<string, string>>({});\n  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);\n  const [dragActive, setDragActive] = useState(false);\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  // Dynamic title and description based on multiple setting\n  const modalTitle = title || (multiple ? \"Upload Files\" : \"Upload File\");\n  const modalDescription =\n    description ||\n    (multiple\n      ? \"Upload files and fill in the required information\"\n      : \"Upload a file and fill in the required information\");\n\n  const uploadProgress = useUploadProgress();\n\n  const { uploadAndReturn } = useFileUpload({\n    onUploadStart: uploadProgress.startUpload,\n    onProgress: uploadProgress.updateProgress,\n    onUploadComplete: uploadProgress.completeUpload,\n    onUploadError: uploadProgress.failUpload,\n  });\n\n  const handleClose = () => {\n    setIsOpen(false);\n    setFieldValues({});\n    setSelectedFiles([]);\n    setDragActive(false);\n    setFieldErrors({});\n  };\n\n  const handleFieldChange = (key: string, value: string) => {\n    setFieldValues((prev) => ({ ...prev, [key]: value }));\n\n    // Clear error when user starts typing\n    if (fieldErrors[key]) {\n      setFieldErrors((prev) => ({ ...prev, [key]: \"\" }));\n    }\n  };\n\n  const validateFields = (): boolean => {\n    const errors: Record<string, string> = {};\n\n    inputFields?.forEach((field) => {\n      const value = fieldValues[field.key] || \"\";\n\n      if (field.required && !value.trim()) {\n        errors[field.key] = `${field.label} is required`;\n        return;\n      }\n\n      if (field.validation && value.trim()) {\n        const validationError = field.validation(value.trim());\n        if (validationError) {\n          errors[field.key] = validationError;\n        }\n      }\n    });\n\n    setFieldErrors(errors);\n    return Object.keys(errors).length === 0;\n  };\n\n  const handleFileSelect = (newFiles: File[]) => {\n    const validFiles: File[] = [];\n    // Remove toast usage, just skip invalid files\n    newFiles.forEach((file) => {\n      const validationError = validateFile(\n        file,\n        allowedFileTypes,\n        maxFileSizeBytes,\n      );\n      if (!validationError) {\n        validFiles.push(file);\n      }\n    });\n\n    if (validFiles.length > 0) {\n      if (multiple) {\n        setSelectedFiles((prev) => [...prev, ...validFiles]);\n      } else {\n        setSelectedFiles(validFiles.slice(0, 1)); // Only take the first file for single upload\n      }\n    }\n  };\n\n  const handleDragEnter = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragActive(true);\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragActive(false);\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragActive(false);\n\n    const files = Array.from(e.dataTransfer.files);\n    if (files.length > 0) {\n      handleFileSelect(files);\n    }\n  };\n\n  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const files = e.target.files;\n    if (files && files.length > 0) {\n      handleFileSelect(Array.from(files));\n    }\n  };\n\n  const handleUpload = async () => {\n    if (selectedFiles.length === 0) {\n      // No toast, just return\n      return;\n    }\n\n    if (!validateFields()) {\n      // No toast, just return\n      return;\n    }\n\n    // Close modal immediately when upload starts\n    handleClose();\n\n    try {\n      // Upload all selected files and get results\n      const uploadPromises = selectedFiles.map((file) => uploadAndReturn(file));\n      const results = await Promise.all(uploadPromises);\n\n      // Filter only successful uploads and extract their data\n      const successfulData = results\n        .filter((result) => result.success && result.data)\n        .map((result) => result.data!);\n\n      // Only call onSuccess if there are successful uploads\n      if (successfulData.length > 0) {\n        await onSuccess(successfulData, fieldValues);\n      }\n    } catch {\n      // Error is already handled in the hook/progress panel\n    }\n  };\n\n  const removeFile = (fileToRemove: File) => {\n    setSelectedFiles((prev) => prev.filter((file) => file !== fileToRemove));\n  };\n\n  const canSubmit =\n    selectedFiles.length > 0 &&\n    inputFields?.every(\n      (field) =>\n        !field.required ||\n        (fieldValues[field.key] && fieldValues[field.key].trim()),\n    );\n\n  return (\n    <>\n      <Dialog open={isOpen} onOpenChange={setIsOpen}>\n        <DialogTrigger asChild>\n          {trigger || (\n            <Button className=\"cursor-pointer\" disabled={isProcessing}>\n              {isProcessing && (\n                <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n              )}\n              <Upload className=\"h-4 w-4\" />\n              {multiple ? \"Upload Files\" : \"Upload File\"}\n            </Button>\n          )}\n        </DialogTrigger>\n        <DialogContent className=\"sm:max-w-md\">\n          <DialogHeader>\n            <DialogTitle>{modalTitle}</DialogTitle>\n            <p className=\"text-sm text-muted-foreground\">{modalDescription}</p>\n          </DialogHeader>\n\n          <div className=\"space-y-4\">\n            {/* Input Fields */}\n            {inputFields?.map((field) => (\n              <div key={field.key} className=\"space-y-2\">\n                <label htmlFor={field.key} className=\"text-sm font-medium\">\n                  {field.label}\n                  {field.required && (\n                    <span className=\"text-destructive ml-1\">*</span>\n                  )}\n                </label>\n                <Input\n                  id={field.key}\n                  value={fieldValues[field.key] || \"\"}\n                  onChange={(e) => handleFieldChange(field.key, e.target.value)}\n                  placeholder={field.placeholder}\n                  className={fieldErrors[field.key] ? \"border-destructive\" : \"\"}\n                />\n                {fieldErrors[field.key] && (\n                  <p className=\"text-sm text-destructive\">\n                    {fieldErrors[field.key]}\n                  </p>\n                )}\n              </div>\n            ))}\n\n            {/* File Upload Area */}\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium\">\n                {multiple ? \"Files\" : \"File\"}{\" \"}\n                <span className=\"text-destructive ml-1\">*</span>\n              </label>\n              <div\n                className={`border border-dashed rounded-lg p-4 text-center transition-colors cursor-pointer ${\n                  dragActive\n                    ? \"border-primary bg-primary/5\"\n                    : \"border-muted-foreground/30 hover:border-primary/60\"\n                }`}\n                onDragEnter={handleDragEnter}\n                onDragLeave={handleDragLeave}\n                onDragOver={handleDragOver}\n                onDrop={handleDrop}\n                onClick={() => document.getElementById(\"file-upload\")?.click()}\n              >\n                {selectedFiles.length > 0 ? (\n                  <div className=\"space-y-2\">\n                    {selectedFiles.map((file, index) => (\n                      <div\n                        key={`${file.name}-${index}`}\n                        className=\"flex items-center justify-between bg-muted/30 px-3 py-2 rounded\"\n                      >\n                        <div className=\"flex items-center space-x-2 min-w-0 flex-1\">\n                          <Upload className=\"h-3 w-3 text-muted-foreground flex-shrink-0\" />\n                          <span className=\"text-sm font-medium truncate\">\n                            {file.name}\n                          </span>\n                          <span className=\"text-xs text-muted-foreground flex-shrink-0\">\n                            ({Math.round(file.size / 1000)}KB)\n                          </span>\n                        </div>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          className=\"h-6 w-6 p-0 flex-shrink-0\"\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            removeFile(file);\n                          }}\n                        >\n                          <X className=\"h-3 w-3\" />\n                        </Button>\n                      </div>\n                    ))}\n                    {multiple && (\n                      <div className=\"text-xs text-muted-foreground pt-2 mt-3 border-t border-muted-foreground/20\">\n                        Click to add more files or drag and drop\n                      </div>\n                    )}\n                  </div>\n                ) : (\n                  <div className=\"space-y-3\">\n                    <Upload className=\"h-6 w-6 text-muted-foreground mx-auto\" />\n                    <div>\n                      <div className=\"text-sm font-medium\">\n                        Click to upload{multiple ? \" files\" : \"\"}\n                      </div>\n                      <div className=\"text-xs text-muted-foreground mt-1\">\n                        or drag and drop\n                      </div>\n                    </div>\n                    {allowedFileTypes.length > 0 && (\n                      <p className=\"text-xs text-muted-foreground\">\n                        Supported: {allowedFileTypes.join(\", \")}\n                      </p>\n                    )}\n                    <p className=\"text-xs text-muted-foreground\">\n                      Max size: {Math.round(maxFileSizeBytes / 1000 / 1000)}MB\n                    </p>\n                  </div>\n                )}\n                <input\n                  type=\"file\"\n                  className=\"sr-only\"\n                  id=\"file-upload\"\n                  onChange={handleFileInputChange}\n                  accept={allowedFileTypes.join(\",\")}\n                  multiple={multiple}\n                />\n              </div>\n            </div>\n          </div>\n\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={handleClose}>\n              Cancel\n            </Button>\n            <Button onClick={handleUpload} disabled={!canSubmit}>\n              {selectedFiles.length > 1\n                ? `Upload ${selectedFiles.length} Files & Process`\n                : \"Upload & Process\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      <UploadProgress\n        files={uploadProgress.uploadProgressFiles}\n        onClose={uploadProgress.clearAllUploads}\n      />\n    </>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/file-uploader/use-file-upload.ts",
      "content": "import { useState } from \"react\";\nimport {\n  uploadFileApiV1FilesPost,\n  readFileContentApiV1FilesIdContentGet,\n} from \"@llamaindex/cloud/api\";\n\nexport interface FileUploadData {\n  file: File;\n  fileId: string;\n  url?: string;\n}\n\nexport interface UploadResult {\n  success: boolean;\n  data: FileUploadData | null;\n  error: Error | null;\n}\n\nexport interface UseFileUploadOptions {\n  onProgress?: (file: File, progress: number) => void;\n  onUploadStart?: (file: File) => void;\n  onUploadComplete?: (file: File) => void;\n  onUploadError?: (file: File, error: string) => void;\n}\n\nexport interface UseFileUploadReturn {\n  isUploading: boolean;\n  uploadAndReturn: (file: File) => Promise<UploadResult>;\n}\n\nexport function useFileUpload({\n  onProgress,\n  onUploadStart,\n  onUploadComplete,\n  onUploadError,\n}: UseFileUploadOptions = {}): UseFileUploadReturn {\n  const [isUploading, setIsUploading] = useState(false);\n\n  const uploadAndReturn = async (file: File): Promise<UploadResult> => {\n    setIsUploading(true);\n    onUploadStart?.(file);\n\n    try {\n      const response = await uploadFileApiV1FilesPost({\n        body: {\n          upload_file: file,\n        },\n      });\n\n      if (response.error) {\n        throw response.error;\n      }\n\n      const fileId = response.data.id;\n\n      // Real API call with progress simulation\n      onProgress?.(file, 10);\n\n      // Get the file content URL using the file ID\n      const contentResponse = await readFileContentApiV1FilesIdContentGet({\n        path: {\n          id: fileId,\n        },\n      });\n\n      if (contentResponse.error) {\n        throw contentResponse.error;\n      }\n\n      const fileUrl = contentResponse.data.url;\n      onProgress?.(file, 80);\n\n      const fileData: FileUploadData = {\n        file,\n        fileId,\n        url: fileUrl,\n      };\n\n      onProgress?.(file, 100);\n      onUploadComplete?.(file);\n\n      return {\n        success: true,\n        data: fileData,\n        error: null,\n      };\n    } catch (error) {\n      console.error(\"Upload error:\", error);\n      const errorMessage =\n        error instanceof Error ? error.message : \"Upload failed\";\n      onUploadError?.(file, errorMessage);\n\n      return {\n        success: false,\n        data: null,\n        error: error as Error,\n      };\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  return {\n    isUploading,\n    uploadAndReturn,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/file-uploader/file-utils.ts",
      "content": "/**\n * Supported file types for document parsing and extraction\n */\nexport enum FileType {\n  // Images (for document processing and extraction)\n  JPEG = \"jpeg\",\n  JPG = \"jpg\",\n  PNG = \"png\",\n  WEBP = \"webp\",\n\n  // Documents (primary use case)\n  PDF = \"pdf\",\n  DOC = \"doc\",\n  DOCX = \"docx\",\n  XLS = \"xls\",\n  XLSX = \"xlsx\",\n  PPT = \"ppt\",\n  PPTX = \"pptx\",\n\n  // Text files (can be parsed and indexed)\n  TXT = \"txt\",\n  CSV = \"csv\",\n  JSON = \"json\",\n  XML = \"xml\",\n  HTML = \"html\",\n  CSS = \"css\",\n  JS = \"js\",\n  TS = \"ts\",\n  MD = \"md\",\n}\n\n/**\n * File type definitions with extensions, MIME types, and display names\n */\nconst FILE_TYPE_DEFINITIONS: Record<\n  FileType,\n  {\n    extensions: string[];\n    mimeTypes: string[];\n    displayName: string;\n    category: string;\n  }\n> = {\n  [FileType.JPEG]: {\n    extensions: [\"jpg\", \"jpeg\"],\n    mimeTypes: [\"image/jpeg\", \"image/jpg\"],\n    displayName: \"JPEG Image\",\n    category: \"image\",\n  },\n  [FileType.JPG]: {\n    extensions: [\"jpg\", \"jpeg\"],\n    mimeTypes: [\"image/jpeg\", \"image/jpg\"],\n    displayName: \"JPG Image\",\n    category: \"image\",\n  },\n  [FileType.PNG]: {\n    extensions: [\"png\"],\n    mimeTypes: [\"image/png\"],\n    displayName: \"PNG Image\",\n    category: \"image\",\n  },\n  [FileType.WEBP]: {\n    extensions: [\"webp\"],\n    mimeTypes: [\"image/webp\"],\n    displayName: \"WebP Image\",\n    category: \"image\",\n  },\n  [FileType.PDF]: {\n    extensions: [\"pdf\"],\n    mimeTypes: [\"application/pdf\"],\n    displayName: \"PDF Document\",\n    category: \"document\",\n  },\n  [FileType.DOC]: {\n    extensions: [\"doc\"],\n    mimeTypes: [\"application/msword\"],\n    displayName: \"Word Document\",\n    category: \"document\",\n  },\n  [FileType.DOCX]: {\n    extensions: [\"docx\"],\n    mimeTypes: [\n      \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    ],\n    displayName: \"Word Document\",\n    category: \"document\",\n  },\n  [FileType.XLS]: {\n    extensions: [\"xls\"],\n    mimeTypes: [\"application/vnd.ms-excel\"],\n    displayName: \"Excel Spreadsheet\",\n    category: \"document\",\n  },\n  [FileType.XLSX]: {\n    extensions: [\"xlsx\"],\n    mimeTypes: [\n      \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n    ],\n    displayName: \"Excel Spreadsheet\",\n    category: \"document\",\n  },\n  [FileType.PPT]: {\n    extensions: [\"ppt\"],\n    mimeTypes: [\"application/vnd.ms-powerpoint\"],\n    displayName: \"PowerPoint Presentation\",\n    category: \"document\",\n  },\n  [FileType.PPTX]: {\n    extensions: [\"pptx\"],\n    mimeTypes: [\n      \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n    ],\n    displayName: \"PowerPoint Presentation\",\n    category: \"document\",\n  },\n  [FileType.TXT]: {\n    extensions: [\"txt\"],\n    mimeTypes: [\"text/plain\"],\n    displayName: \"Text File\",\n    category: \"text\",\n  },\n  [FileType.CSV]: {\n    extensions: [\"csv\"],\n    mimeTypes: [\"text/csv\"],\n    displayName: \"CSV File\",\n    category: \"text\",\n  },\n  [FileType.JSON]: {\n    extensions: [\"json\"],\n    mimeTypes: [\"application/json\"],\n    displayName: \"JSON File\",\n    category: \"text\",\n  },\n  [FileType.XML]: {\n    extensions: [\"xml\"],\n    mimeTypes: [\"application/xml\", \"text/xml\"],\n    displayName: \"XML File\",\n    category: \"text\",\n  },\n  [FileType.HTML]: {\n    extensions: [\"html\", \"htm\"],\n    mimeTypes: [\"text/html\"],\n    displayName: \"HTML File\",\n    category: \"text\",\n  },\n  [FileType.CSS]: {\n    extensions: [\"css\"],\n    mimeTypes: [\"text/css\"],\n    displayName: \"CSS File\",\n    category: \"text\",\n  },\n  [FileType.JS]: {\n    extensions: [\"js\"],\n    mimeTypes: [\"application/javascript\", \"text/javascript\"],\n    displayName: \"JavaScript File\",\n    category: \"text\",\n  },\n  [FileType.TS]: {\n    extensions: [\"ts\"],\n    mimeTypes: [\"application/typescript\", \"text/typescript\"],\n    displayName: \"TypeScript File\",\n    category: \"text\",\n  },\n  [FileType.MD]: {\n    extensions: [\"md\", \"markdown\"],\n    mimeTypes: [\"text/markdown\"],\n    displayName: \"Markdown File\",\n    category: \"text\",\n  },\n};\n\n/**\n * Predefined file type groups for common use cases\n */\nexport const FILE_TYPE_GROUPS = {\n  IMAGES: [FileType.JPEG, FileType.JPG, FileType.PNG, FileType.WEBP],\n  DOCUMENTS: [\n    FileType.PDF,\n    FileType.DOC,\n    FileType.DOCX,\n    FileType.XLS,\n    FileType.XLSX,\n    FileType.PPT,\n    FileType.PPTX,\n  ],\n  TEXT: [\n    FileType.TXT,\n    FileType.CSV,\n    FileType.JSON,\n    FileType.XML,\n    FileType.HTML,\n    FileType.CSS,\n    FileType.JS,\n    FileType.TS,\n    FileType.MD,\n  ],\n  SPREADSHEETS: [FileType.XLS, FileType.XLSX, FileType.CSV],\n  PRESENTATIONS: [FileType.PPT, FileType.PPTX],\n  COMMON_IMAGES: [FileType.JPEG, FileType.JPG, FileType.PNG, FileType.WEBP],\n  OFFICE_DOCS: [\n    FileType.PDF,\n    FileType.DOC,\n    FileType.DOCX,\n    FileType.XLS,\n    FileType.XLSX,\n    FileType.PPT,\n    FileType.PPTX,\n  ],\n};\n\n/**\n * Gets file type definition by FileType enum\n */\nexport const getFileTypeDefinition = (fileType: FileType) => {\n  return FILE_TYPE_DEFINITIONS[fileType];\n};\n\n/**\n * Gets all supported extensions for a FileType\n */\nexport const getFileExtensions = (fileType: FileType): string[] => {\n  return FILE_TYPE_DEFINITIONS[fileType].extensions;\n};\n\n/**\n * Gets all supported MIME types for a FileType\n */\nexport const getFileMimeTypes = (fileType: FileType): string[] => {\n  return FILE_TYPE_DEFINITIONS[fileType].mimeTypes;\n};\n\n/**\n * Checks if a file matches the given FileType\n */\nexport const isFileTypeMatch = (file: File, fileType: FileType): boolean => {\n  const definition = FILE_TYPE_DEFINITIONS[fileType];\n  const fileExtension = file.name.split(\".\").pop()?.toLowerCase();\n\n  // Check extension match\n  const extensionMatch =\n    fileExtension && definition.extensions.includes(fileExtension);\n\n  // Check MIME type match\n  const mimeTypeMatch = definition.mimeTypes.includes(file.type);\n\n  return extensionMatch || mimeTypeMatch;\n};\n\n/**\n * File validation with FileType enum system\n */\nexport const validateFile = (\n  file: File,\n  allowedFileTypes: FileType[] = [],\n  maxFileSizeBytes: number = 10 * 1000 * 1000, // 10MB in decimal\n): string | null => {\n  // Check file size\n  if (file.size > maxFileSizeBytes) {\n    return `File size exceeds ${Math.round(maxFileSizeBytes / 1000 / 1000)}MB limit`;\n  }\n\n  // Check file type if restrictions are specified\n  if (allowedFileTypes.length > 0) {\n    const isValidType = allowedFileTypes.some((fileType) => {\n      return isFileTypeMatch(file, fileType);\n    });\n\n    if (!isValidType) {\n      const allowedTypeNames = allowedFileTypes.map((fileType) => {\n        return FILE_TYPE_DEFINITIONS[fileType].displayName;\n      });\n      return `File type not allowed. Allowed types: ${allowedTypeNames.join(\", \")}`;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Gets all file types by category\n */\nexport const getFileTypesByCategory = (category: string): FileType[] => {\n  return Object.entries(FILE_TYPE_DEFINITIONS)\n    .filter(([, definition]) => definition.category === category)\n    .map(([fileType]) => fileType as FileType);\n};\n\n/**\n * Creates a validation function for a specific file type group\n */\nexport const createFileTypeValidator = (\n  allowedTypes: FileType[],\n  maxSizeBytes = 10 * 1000 * 1000,\n) => {\n  return (file: File) => validateFile(file, allowedTypes, maxSizeBytes);\n};\n\n/**\n * Formats file size in human-readable format using decimal (SI) units\n * Uses powers of 1000 for true KB, MB, GB calculations\n */\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return \"0 Bytes\";\n\n  const k = 1000;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n};\n\n/**\n * Checks if the current environment supports the File API\n */\nexport const isFileApiSupported = (): boolean => {\n  return typeof File !== \"undefined\" && typeof FileReader !== \"undefined\";\n};\n\n/**\n * Checks if the current environment supports the Web Crypto API\n */\nexport const isCryptoSupported = (): boolean => {\n  return typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\";\n};\n",
      "type": "registry:lib"
    }
  ]
}