{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "extracted-data",
  "type": "registry:block",
  "title": "Extracted Data Display",
  "description": "Components for displaying and editing extracted data",
  "files": [
    {
      "path": "registry/new-york/extracted-data/extracted-data-display.tsx",
      "content": "\"use client\";\nimport { useState, useMemo } from \"react\";\nimport type { ExtractedDataDisplayProps } from \"./types\";\nimport { PropertyRenderer } from \"./property-renderer\";\nimport {\n  getFieldDisplayInfo,\n  getFieldLabelClasses,\n  getFieldLabelText,\n} from \"./field-display-utils\";\nimport { reconcileDataWithJsonSchema } from \"./schema-reconciliation\";\nimport { flattenConfidence } from \"./confidence-utils\";\n\nexport function ExtractedDataDisplay({\n  data,\n  confidence = {},\n  emptyMessage = \"No extracted data available\",\n  onChange,\n  editable = true,\n  jsonSchema,\n}: ExtractedDataDisplayProps) {\n  const [changedPaths, setChangedPaths] = useState<Set<string>>(new Set());\n\n  // Flatten confidence object to keypath: value format\n  const flattenedConfidence = useMemo(() => {\n    return flattenConfidence(confidence);\n  }, [confidence]);\n\n  // Perform schema reconciliation if schema is provided\n  const reconciliationResult = useMemo(() => {\n    if (!jsonSchema) {\n      return null;\n    }\n    return reconcileDataWithJsonSchema(data, jsonSchema);\n  }, [data, jsonSchema]);\n\n  // Use reconciled data if available, otherwise use original data\n  const displayData = reconciliationResult?.data || data;\n  const fieldMetadata = reconciliationResult?.metadata || {};\n  const validationErrors = reconciliationResult?.validationErrors || [];\n\n  const renderFieldLabel = (key: string, additionalClasses?: string) => {\n    const fieldInfo = getFieldDisplayInfo(\n      key,\n      fieldMetadata,\n      validationErrors,\n      [key],\n    );\n    const baseClasses = getFieldLabelClasses(fieldInfo);\n    const finalClasses = additionalClasses\n      ? `${baseClasses} ${additionalClasses}`\n      : baseClasses;\n\n    return <div className={finalClasses}>{getFieldLabelText(fieldInfo)}</div>;\n  };\n\n  if (!displayData || Object.keys(displayData).length === 0) {\n    return (\n      <div className=\"text-sm text-gray-500 text-center py-4\">\n        {emptyMessage}\n      </div>\n    );\n  }\n\n  const handleUpdate = (\n    path: string[],\n    newValue: unknown,\n    additionalPaths?: string[][],\n  ) => {\n    if (!editable || !onChange) return;\n\n    const newData = { ...data };\n    let current: Record<string, unknown> = newData;\n\n    // Navigate to the parent of the target property\n    for (let i = 0; i < path.length - 1; i++) {\n      current = current[path[i]] as Record<string, unknown>;\n    }\n\n    // Set the new value\n    current[path[path.length - 1]] = newValue;\n\n    // Track changed paths - main path and any additional paths\n    const pathsToTrack = [path, ...(additionalPaths || [])];\n\n    setChangedPaths((prev) => {\n      const newSet = new Set(prev);\n      pathsToTrack.forEach((p) => {\n        newSet.add(p.join(\".\"));\n      });\n      return newSet;\n    });\n\n    onChange(newData);\n  };\n\n  return (\n    <div>\n      {Object.keys(jsonSchema?.properties || {}).map((key) => {\n        const value = displayData[key];\n        // If the value is an array of objects, show key on separate line with table below\n        if (\n          Array.isArray(value) &&\n          value.length > 0 &&\n          typeof value[0] === \"object\" &&\n          value[0] !== null\n        ) {\n          return (\n            <div key={key}>\n              {renderFieldLabel(key)}\n              <div>\n                <PropertyRenderer\n                  keyPath={[key]}\n                  value={value}\n                  onUpdate={handleUpdate}\n                  confidence={flattenedConfidence}\n                  changedPaths={changedPaths}\n                  fieldMetadata={fieldMetadata}\n                  validationErrors={validationErrors}\n                />\n              </div>\n            </div>\n          );\n        }\n        // If the value is an object, show key on separate line\n        else if (typeof value === \"object\" && value !== null) {\n          return (\n            <div key={key}>\n              {renderFieldLabel(key)}\n              <PropertyRenderer\n                keyPath={[key]}\n                value={value}\n                onUpdate={handleUpdate}\n                confidence={flattenedConfidence}\n                changedPaths={changedPaths}\n                fieldMetadata={fieldMetadata}\n                validationErrors={validationErrors}\n              />\n            </div>\n          );\n        } else {\n          // For primitive values and primitive arrays, show key and value on same line\n          return (\n            <div key={key}>\n              <div className=\"flex items-start gap-6\">\n                {renderFieldLabel(key, \"min-w-0 flex-shrink-0\")}\n                <div className=\"flex-1 min-w-0\">\n                  <PropertyRenderer\n                    keyPath={[key]}\n                    value={value}\n                    onUpdate={handleUpdate}\n                    confidence={flattenedConfidence}\n                    changedPaths={changedPaths}\n                    fieldMetadata={fieldMetadata}\n                    validationErrors={validationErrors}\n                  />\n                </div>\n              </div>\n            </div>\n          );\n        }\n      })}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/extracted-data/property-renderer/property-renderer.tsx",
      "content": "\"use client\";\nimport { EditableField } from \"../editable-field\";\nimport { TableRenderer } from \"../table-renderer\";\nimport { ListRenderer } from \"../list-renderer\";\nimport {\n  isPropertyChanged,\n  filterConfidenceForArray,\n  isArrayOfObjects,\n  shouldShowKeyOnSeparateLine,\n} from \"./property-renderer-utils\";\nimport type { FieldMetadata, ValidationError } from \"../schema-reconciliation\";\nimport {\n  getFieldDisplayInfo,\n  getFieldLabelClasses,\n  getFieldLabelText,\n} from \"../field-display-utils\";\nimport { PrimitiveType, toPrimitiveType } from \"../primitive-validation\";\nimport { findFieldMetadata } from \"../metadata-path-utils\";\n\ninterface PropertyRendererProps {\n  keyPath: string[];\n  value: unknown;\n  onUpdate: (\n    path: string[],\n    newValue: unknown,\n    additionalPaths?: string[][],\n  ) => void;\n  confidence?: Record<string, number>;\n  changedPaths?: Set<string>;\n  // Schema reconciliation results from parent\n  fieldMetadata?: Record<string, FieldMetadata>;\n  validationErrors?: ValidationError[];\n}\n\nexport function PropertyRenderer({\n  keyPath,\n  value,\n  onUpdate,\n  confidence,\n  changedPaths,\n  fieldMetadata = {},\n  validationErrors = [],\n}: PropertyRendererProps) {\n  const pathString = keyPath.join(\".\");\n  const isChanged = isPropertyChanged(changedPaths, keyPath);\n\n  // Helper function to render field labels with schema info\n  const renderFieldLabel = (\n    key: string,\n    currentKeyPath: string[],\n    additionalClasses?: string,\n  ) => {\n    const fieldInfo = getFieldDisplayInfo(\n      key,\n      fieldMetadata,\n      validationErrors,\n      currentKeyPath,\n    );\n    const baseClasses = getFieldLabelClasses(fieldInfo);\n    const finalClasses = additionalClasses\n      ? `${baseClasses} ${additionalClasses}`\n      : baseClasses;\n\n    return <div className={finalClasses}>{getFieldLabelText(fieldInfo)}</div>;\n  };\n\n  if (value === null || value === undefined) {\n    const fieldInfo = findFieldMetadata(keyPath, fieldMetadata);\n    const expectedType = fieldInfo?.schemaType\n      ? toPrimitiveType(fieldInfo.schemaType)\n      : PrimitiveType.STRING;\n    const isRequired = fieldInfo?.isRequired || false;\n\n    return (\n      <EditableField\n        value=\"N/A\"\n        onSave={(newValue) => onUpdate(keyPath, newValue)}\n        confidence={confidence?.[pathString]}\n        isChanged={isChanged}\n        expectedType={expectedType}\n        required={isRequired}\n      />\n    );\n  }\n\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      // For empty arrays, still show the ListRenderer so users can add items\n      return (\n        <ListRenderer\n          data={value}\n          onUpdate={() => {}} // Empty array has no items to update\n          onAdd={(newValue) => {\n            const newArray = [newValue];\n\n            // Track the array change and the new item\n            const newItemPath = [...keyPath, \"0\"];\n            onUpdate(keyPath, newArray, [newItemPath]);\n          }}\n          confidence={{}}\n          changedPaths={changedPaths}\n          keyPath={keyPath}\n          fieldMetadata={fieldMetadata}\n        />\n      );\n    }\n\n    const arrayConfidence = filterConfidenceForArray(confidence, keyPath);\n\n    // Check if it's an array of objects\n    if (isArrayOfObjects(value)) {\n      // For arrays of objects, we want to show the table below the key\n      // This will be handled by the parent component\n      return (\n        <TableRenderer\n          data={value as Record<string, unknown>[]}\n          onUpdate={(index, key, newValue, affectedPaths) => {\n            const newArray = [...value];\n            newArray[index] = { ...newArray[index], [key]: newValue };\n\n            // Use the affectedPaths provided by TableRenderer for accurate path tracking\n            if (affectedPaths && affectedPaths.length > 0) {\n              // Convert relative paths to absolute paths for ExtractedDataDisplay context\n              const absolutePaths = affectedPaths.map((path) => {\n                // path format: \"0.contact.email\" -> convert to [\"keyPath\", \"0\", \"contact\", \"email\"]\n                const pathParts = path.split(\".\");\n                return [...keyPath, ...pathParts];\n              });\n              onUpdate(keyPath, newArray, absolutePaths);\n            } else {\n              // Fallback for backward compatibility\n              const cellPath = [...keyPath, String(index), key];\n              onUpdate(keyPath, newArray, [cellPath]);\n            }\n          }}\n          onAddRow={(newRow) => {\n            const newArray = [...value, newRow];\n\n            // Track the array change and the new row\n            const newRowPath = [...keyPath, String(value.length)];\n            onUpdate(keyPath, newArray, [newRowPath]);\n          }}\n          onDeleteRow={(index) => {\n            const newArray = (value as Record<string, unknown>[]).filter(\n              (_, i) => i !== index,\n            );\n\n            // Track the array change - when deleting, we track the entire array as changed\n            onUpdate(keyPath, newArray, [keyPath]);\n          }}\n          confidence={arrayConfidence}\n          changedPaths={changedPaths}\n          keyPath={keyPath}\n          fieldMetadata={fieldMetadata}\n          validationErrors={validationErrors}\n        />\n      );\n    } else {\n      // Array of primitives\n      return (\n        <ListRenderer\n          data={value}\n          onUpdate={(index, newValue) => {\n            const newArray = [...value];\n            newArray[index] = newValue;\n\n            // Track both the array change and the specific item change\n            const itemPath = [...keyPath, String(index)];\n            onUpdate(keyPath, newArray, [itemPath]);\n          }}\n          onAdd={(newValue) => {\n            const newArray = [...value, newValue];\n\n            // Track the array change and the new item\n            const newItemPath = [...keyPath, String(value.length)];\n            onUpdate(keyPath, newArray, [newItemPath]);\n          }}\n          onDelete={(index) => {\n            const newArray = value.filter((_, i) => i !== index);\n\n            // Track the array change - when deleting, we track the entire array as changed\n            onUpdate(keyPath, newArray, [keyPath]);\n          }}\n          confidence={arrayConfidence}\n          changedPaths={changedPaths}\n          keyPath={keyPath}\n          fieldMetadata={fieldMetadata}\n        />\n      );\n    }\n  }\n\n  if (typeof value === \"object\") {\n    return (\n      <div className=\"relative\">\n        <div className=\"pl-4 border-l-2 border-gray-200\">\n          {Object.entries(value).map(([key, val]) => {\n            // If the value is an array of objects or object, show key on separate line\n            if (shouldShowKeyOnSeparateLine(val)) {\n              return (\n                <div key={key}>\n                  {renderFieldLabel(key, [...keyPath, key])}\n                  <div className=\"mt-2\">\n                    <PropertyRenderer\n                      keyPath={[...keyPath, key]}\n                      value={val}\n                      onUpdate={onUpdate}\n                      confidence={confidence}\n                      changedPaths={changedPaths}\n                      fieldMetadata={fieldMetadata}\n                      validationErrors={validationErrors}\n                    />\n                  </div>\n                </div>\n              );\n            } else {\n              // For primitive values and primitive arrays, show key and value on same line\n              return (\n                <div key={key}>\n                  <div className=\"flex items-start gap-6\">\n                    {renderFieldLabel(\n                      key,\n                      [...keyPath, key],\n                      \"min-w-0 flex-shrink-0\",\n                    )}\n                    <div className=\"flex-1 min-w-0\">\n                      <PropertyRenderer\n                        keyPath={[...keyPath, key]}\n                        value={val}\n                        onUpdate={onUpdate}\n                        confidence={confidence}\n                        changedPaths={changedPaths}\n                        fieldMetadata={fieldMetadata}\n                        validationErrors={validationErrors}\n                      />\n                    </div>\n                  </div>\n                </div>\n              );\n            }\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  // Primitive value\n  const fieldInfo = findFieldMetadata(keyPath, fieldMetadata);\n  const expectedType = fieldInfo?.schemaType\n    ? toPrimitiveType(fieldInfo.schemaType)\n    : PrimitiveType.STRING;\n  const isRequired = fieldInfo?.isRequired || false;\n\n  return (\n    <EditableField\n      value={value}\n      onSave={(newValue) => onUpdate(keyPath, newValue)}\n      confidence={confidence?.[pathString]}\n      isChanged={isChanged}\n      expectedType={expectedType}\n      required={isRequired}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/extracted-data/editable-field/editable-field.tsx",
      "content": "\"use client\";\nimport React, { useState, useRef, useLayoutEffect } from \"react\";\nimport { getConfidenceBackgroundClass } from \"../confidence-utils\";\nimport { isLowConfidence } from \"@/lib\";\nimport { PrimitiveType, convertPrimitiveValue } from \"../primitive-validation\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\n\ninterface EditableFieldProps {\n  value: unknown;\n  onSave: (newValue: unknown) => void;\n  confidence?: number;\n  isChanged?: boolean;\n  showBorder?: boolean;\n  onConfidenceUpdate?: (newConfidence: number) => void;\n  /** Expected primitive type for validation */\n  expectedType?: PrimitiveType;\n  /** Whether the field is required (prevents empty values for numbers) */\n  required?: boolean;\n  className?: string;\n}\n\nexport function EditableField({\n  value,\n  onSave,\n  confidence,\n  isChanged,\n  showBorder = true,\n  onConfidenceUpdate,\n  expectedType = PrimitiveType.STRING,\n  required = false,\n  className,\n}: EditableFieldProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [editValue, setEditValue] = useState(\n    value === null || value === undefined ? \"\" : String(value),\n  );\n  const [localConfidence, setLocalConfidence] = useState(confidence ?? 1);\n\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useLayoutEffect(() => {\n    if (containerRef.current) {\n      const parent = containerRef.current.parentElement;\n      if (parent) {\n        const contentHeight = parent.clientHeight;\n        containerRef.current.style.height = `${contentHeight}px`;\n      }\n    }\n  }, [value]);\n\n  const handleSave = () => {\n    // Check if required number field is empty\n    if (\n      required &&\n      expectedType === PrimitiveType.NUMBER &&\n      editValue.trim() === \"\"\n    ) {\n      // Don't save if required number field is empty\n      return;\n    }\n\n    // Convert the input value to the correct type\n    const convertedValue = convertPrimitiveValue(\n      editValue,\n      expectedType,\n      required,\n    );\n\n    // Save the converted value\n    onSave(convertedValue);\n\n    // Update confidence to 100% after user confirms the edit\n    setLocalConfidence(1.0);\n    onConfidenceUpdate?.(1.0);\n    setIsOpen(false);\n  };\n\n  const handleCancel = () => {\n    setEditValue(value === null || value === undefined ? \"\" : String(value));\n    setIsOpen(false);\n  };\n\n  const handleOpenChange = (open: boolean) => {\n    setIsOpen(open);\n    if (open) {\n      setEditValue(value === null || value === undefined ? \"\" : String(value));\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey && !e.ctrlKey && !e.metaKey) {\n      // Enter alone saves (for all types)\n      e.preventDefault();\n      handleSave();\n    }\n    // Cmd/Shift/Ctrl + Enter allows newline (default behavior for textarea)\n    if (e.key === \"Escape\") {\n      handleCancel();\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setEditValue(e.target.value);\n  };\n\n  const handleTextareaChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setEditValue(e.target.value);\n  };\n\n  const handleSelectChange = (value: string) => {\n    setEditValue(value);\n  };\n\n  // Use local confidence if available, otherwise use prop confidence\n  const currentConfidence = localConfidence ?? confidence;\n  const displayValue =\n    value === null || value === undefined || value === \"\" ? \"\" : String(value);\n  const backgroundClass = isChanged\n    ? \"bg-green-50\"\n    : getConfidenceBackgroundClass(currentConfidence);\n  const hoverClass = backgroundClass.includes(\"bg-orange-50\")\n    ? \"hover:bg-orange-100\"\n    : backgroundClass.includes(\"bg-green-50\")\n      ? \"hover:bg-green-100\"\n      : \"hover:bg-gray-100\";\n  const defaultBorderClass = showBorder\n    ? isLowConfidence(currentConfidence)\n      ? \"border-b-2 border-orange-300\"\n      : \"border-b border-gray-200\"\n    : \"\";\n  const paddingClass = \"p-2\";\n\n  const renderEditInput = () => {\n    switch (expectedType) {\n      case PrimitiveType.BOOLEAN:\n        return (\n          <Select onValueChange={handleSelectChange} value={editValue}>\n            <SelectTrigger className=\"w-full\">\n              <SelectValue placeholder=\"Select a value\" />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"true\">true</SelectItem>\n              <SelectItem value=\"false\">false</SelectItem>\n            </SelectContent>\n          </Select>\n        );\n      case PrimitiveType.STRING:\n        // Use textarea for string inputs to allow multiline text\n        return (\n          <Textarea\n            value={editValue}\n            onChange={handleTextareaChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Enter value\"\n            className=\"w-full min-h-[100px] resize-none\"\n            autoFocus\n          />\n        );\n      case PrimitiveType.NUMBER:\n        return (\n          <Input\n            type=\"number\"\n            value={editValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Enter a number\"\n            className=\"w-full\"\n            autoFocus\n            required={required}\n          />\n        );\n      default:\n        return (\n          <Input\n            value={editValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Enter value\"\n            className=\"w-full\"\n            autoFocus\n          />\n        );\n    }\n  };\n\n  return (\n    <Popover open={isOpen} onOpenChange={handleOpenChange}>\n      <PopoverTrigger asChild>\n        <div\n          ref={containerRef}\n          className={`cursor-pointer ${showBorder ? \"min-h-8\" : \"w-full\"} flex items-center ${defaultBorderClass} ${paddingClass} ${backgroundClass} ${hoverClass} ${className}`}\n        >\n          <span className=\"text-sm accent-foreground truncate leading-tight block w-full\">\n            {displayValue}\n          </span>\n        </div>\n      </PopoverTrigger>\n\n      <PopoverContent className=\"w-80\" align=\"start\">\n        <div className=\"space-y-3\">\n          <div className=\"flex items-center gap-2\">\n            <div className=\"text-sm font-medium text-gray-700\">Edit Value</div>\n          </div>\n\n          {renderEditInput()}\n\n          <div className=\"flex justify-end space-x-2\">\n            <Button variant=\"outline\" size=\"sm\" onClick={handleCancel}>\n              Cancel\n            </Button>\n            <Button size=\"sm\" onClick={handleSave}>\n              Save\n            </Button>\n          </div>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}